/*
  HWIO - Hardware In/Out
    This module is the HWIO module for the Z80 emulator. It allows bidirectional data between Javascript and the emulator via
    callbacks and event listeners. It is also responsible for handling hardware interrupts generated by the CPU and user.

// */

if (!objEmulatorFactory) {
  var objEmulatorFactory = {};
}

(function(objEmulatorFactory) {
  if (!objEmulatorFactory.hwioList) {
    objEmulatorFactory.hwioList = [];
  }

  objEmulatorFactory.hwioList.push(function() {
    var hwioRet = {
      name: "z80",
      type: "hwio",
      registeredCallbackList: {
        writePortCbArr: [],
        readPortCbArr: [],
        interruptCbArr: []
      },
      cbsr: {},
      interrupt: {
        interruptsList: [0x10, 0x08],
        currentInterrupt: 0x10,
        interruptClockCycle: 16667
      }
    };

    hwioRet.cbsr.writePortCb = function(cbFunction) {
      hwioRet.registeredCallbackList.writePortCbArr.push(cbFunction);
    };

    hwioRet.cbsr.readPortCb = function(cbFunction) {
      hwioRet.registeredCallbackList.readPortCbArr.push(cbFunction);
    };

    hwioRet.cbsr.currentInterruptCb = function(cbFunction) {
      hwioRet.registeredCallbackList.interruptCbArr.push(cbFunction);
    };

    hwioRet.getKeyBoardKeysHooks = function(emuState, event, eventType) {
      if (eventType === "down") {
        if (emuState.ctrl.emulationRunning) {
          if (event.key === 'a') {
            emuState.ctrl.hwPortData[0x01] |= 0x20;
          }
    
          if (event.key === 'd') {
            emuState.ctrl.hwPortData[0x01] |= 0x40;
          }
    
          if (event.key === ' ') {
            emuState.ctrl.hwPortData[0x01] |= 0x10;;
          }
    
          if (event.key === '1') {
            emuState.ctrl.hwPortData[0x01] |= 0x04;;
          }
    
          if (event.key === 'c') {
            emuState.ctrl.hwPortData[0x01] |= 0x01;;
          }
        }
      } else if (eventType === "up") {
        if (emuState.ctrl.emulationRunning) {
          if (event.key === 'a') {
            emuState.ctrl.hwPortData[0x01] &= 0xff - 0x20;
          }
    
          if (event.key === 'd') {
            emuState.ctrl.hwPortData[0x01] &= 0xff - 0x40;
          }
    
          if (event.key === ' ') {
            emuState.ctrl.hwPortData[0x01] &= 0xff - 0x10;;
          }
    
          if (event.key === '1') {
            emuState.ctrl.hwPortData[0x01] &= 0xff - 0x04;;
          }
    
          if (event.key === 'c') {
            emuState.ctrl.hwPortData[0x01] &= 0xff - 0x01;;
          }
        }
      }
    }

    hwioRet.writePort = function(emuState, address, value, throwError = true) {
      emuState.cpu.pins.wr = true;
      emuState.cpu.pins.iorq = true;

      if (emuState.hwio.registeredCallbackList.writePortCbArr.length === 0) {
        if (throwError) {
          throw { type: "Error", moduleName: hwioRet.type, functionName: "writePort", reason: "No writePort callback function specified. Add one with: emuState.hwio.cbsr.writePortCb(function(emuState, address, value, throwError){...}); ", args: arguments };
        }
      }

      emuState.hwio.registeredCallbackList.writePortCbArr.forEach(cbFunction => {
        if (typeof(cbFunction) === "function") {
          cbFunction(emuState, address, value);
        }
      });

      emuState.cpu.pins.wr = false;
      emuState.cpu.pins.iorq = false;
    };

    hwioRet.readPort = function(emuState, address, throwError = true) {
      emuState.cpu.pins.rd = true;
      emuState.cpu.pins.iorq = true;

      if (emuState.hwio.registeredCallbackList.readPortCbArr.length === 0) {
        if (throwError) {
          throw { type: "Error", moduleName: hwioRet.type, functionName: "readPort", reason: "No readPort callback function specified. Add one with: emuState.hwio.cbsr.readPortCb(function(emuState, address, throwError){...}); ", args: arguments };
        }
      }

      var tmpRead = 0x00;

      emuState.hwio.registeredCallbackList.readPortCbArr.forEach(cbFunction => {
        if (typeof(cbFunction) === "function") {
          tmpRead = cbFunction(emuState, address);
        }
      });

      emuState.cpu.pins.rd = false;
      emuState.cpu.pins.iorq = false;
      
      return tmpRead;
    };

    hwioRet.interruptCheck = function(emuState) {
      if (emuState.cpu.counts.cycles < hwioRet.interrupt.interruptClockCycle) {
        return false;
      }
  
      emuState.cpu.counts.cycles -= emuState.hwio.interrupt.interruptClockCycle;
  
      if (emuState.hwio.interrupt.currentInterrupt === emuState.hwio.interrupt.interruptsList[0]) {
        emuState.hwio.interrupt.currentInterrupt = emuState.hwio.interrupt.interruptsList[1];
      } else {
        emuState.hwio.interrupt.currentInterrupt = emuState.hwio.interrupt.interruptsList[0];
      }
  
      if (emuState.alu.checkAluFlags(emuState.cpu.getRegister(emuState, 'f'), "I")) {
        // We need to push the current PC to (SP) so we can return after executing the interrupt.
        emuState.alu.push(emuState, emuState.cpu.getRegister(emuState, 'pc'));
  
        emuState.cpu.setRegister(emuState, 'pc', emuState.hwio.interrupt.currentInterrupt);

        emuState.hwio.registeredCallbackList.interruptCbArr.forEach(cbFunction => {
          if (typeof(cbFunction) === "function") {
            cbFunction(emuState, emuState.hwio.interrupt.currentInterrupt);
          }
        });
      }

      return true
    };

    return hwioRet;
  });

  if (typeof(module) !== 'undefined') { // Node
    module.exports = objEmulatorFactory.hwioList;
  } else if (typeof define === 'function' && define.amd) { // AMD
    define([], function () {
        'use strict';
        return objEmulatorFactory.hwioList;
    });
  }

})(objEmulatorFactory);
